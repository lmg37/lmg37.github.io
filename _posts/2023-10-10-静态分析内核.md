---
layout: post
title: 静态分析论文
categories: 论文
description: 静态分析；内核；污点流
keywords: 论文
---
# 论文阅读-1

**Statically Discovering High-Order Taint Style Vulnerabilities in OS Kernels**

## 相关知识

1.污点：通常指的是有害或不受信任的数据或信息，当有害数据或信息与其他数据混合时，有可能导致潜在的漏洞或安全问题。

2.污点分析：跟踪和标记潜在有害数据或信息，以便在其被使用或传递到不受信任的地方时，及早发现潜在的风险。

3.高阶污点样式漏洞：有害数据或信息从用户输入到潜在漏洞位置的传递路径跨越了多个程序或函数的边界。文中摘要写出从用户输入到漏洞位置的污点流程跨越了单个入口函数调用（即系统调用）的边界。

举例：

1. 入口函数 A() 接受用户提供的参数作为输入。这个参数包含一个值，可以是整数或者某种数据。
2. 在入口函数 A() 中，用户提供的参数的值被复制到一个全局变量 G 中。全局变量 G 现在包含了用户提供的值。
3. 后续，在另一个入口函数 B() 中，全局变量 G 的值被用作数组的索引，以访问数组中的元素。然而，在这个过程中，没有检查或验证索引的有效性。
4. 这导致了一个潜在的问题，如果用户提供的值导致了超出数组边界的索引，那么在入口函数 B() 中的数组访问就会引发越界访问错误，这可能导致程序崩溃或其他安全漏洞。

"高阶"指的是触发漏洞所需的入口函数调用的数量。与简单的“一次性”污点漏洞不同，其中污点传播局限于单个入口函数调用（即，一阶），在具有状态的软件（如Linux内核）中经常出现的高阶漏洞要难以发现得多，因为需要考虑复杂的跨入口污点传播。

## 挑战

1.要列举有害信息从一个函数的入口函数或系统调用到另一个函数的入口函数的各个情况和复杂路径即跨入口污点流，因为函数入口可以以任意顺序被调用，故列举全部可能性并分析同一入口函数在不同排列组合下具有可扩展性，也就是面对大型复杂数据保持高效的能力。

2.由于上述所说跨入口污点流很长，如果误差积累会造成不稳定性，故分析需要足够准确

本文就是要对高阶漏洞也就是复杂的污点传播路径，跨越多个函数调用和程序入口点的数据流进行准确分析

## 方法

为了挑战1，首先独立分析并且只分析一次入口函数，然后对其构建抽象的总结，其中包括对全局变量的影响。在漏洞发现阶段通过查询总结来构建高阶污点流。

为了挑战2，设计了许多功能集成到静态分析中来提高其精度。比如流敏感进行机会路径敏感分析

在流敏感分析中，不止静态的只分析数据的静态状态，分析器跟踪和记录数据从一个程序点到另一个程序点的传递，以便更准确地理解程序中数据的动态行为。

机会路径敏感分析则意味着工具能够识别和分析程序中不同的执行路径，而不仅仅是一条主要的路径。

再比如处理模糊的全局内存更新

说明可以处理不确定的全局内存更新操作，面对不确定性有一点容忍度。

最终实现高度精确的跨进程流、上下文、字段、索引和机会路径敏感的静态污点分析。

也就是分析程序在不同的函数间，函数调用的上下文及如何被调用，访问修改数据位置，及多个可能的执行路径。

Figure 1，它展示了一个高阶漏洞的示例。在这个例子中，有三个入口函数：`entry0()`、`entry1()`和`entry2()`，它们可以以任意顺序调用。在`entry0()`函数中，用户提供的`user_input`被流到全局变量`d.b[0]`中。然后，当调用`entry1()`函数时，`bar()`函数被调用，此时`d.b[0]`的值被检索并用于一个溢出诱发的加法操作。这个漏洞的最重要特征是，从原始用户输入到最终溢出点的污点流通过全局变量中继，使其成为高阶（更具体地说，是二阶）污点漏洞。SUTURE使用一种摘要方法来有效地枚举跨入口点的高阶污点流。在这个例子中，SUTURE将为每个入口函数创建一个摘要，该摘要包含有关本地和全局变量的污点信息。然后，在漏洞发现阶段，SUTURE将查询这些摘要以构建高阶污点流。通过这种方式，SUTURE能够发现高阶污点漏洞。

## 工作流程

1.输入：目标程序编译的LLVM位码文件

> LLVM位码文件通常是LLVM编译器工具链的一部分，用于在编译、链接和生成目标代码之间进行中间表示的传递。这有助于提高编译器的可维护性、可移植性和性能。

2.静态污点分析：首先对每个入口函数进行污点分析，生成一个汇总，记录了该函数内的本地污点流(有害数据的传播路径)，包括如何处理用户输入和全局变量。这些分析是无序的，即它们不依赖于入口函数的调用顺序。

3.漏洞发现：对各个入口函数进行漏洞检测，并且检查从用户输入到有问题的语句是否存在涉及多个函数调用的跨条目污点流。

4.输出：生成警告的完整信息：警告类型、完整的跨入口污点流以及警告的顺序。

> 每个警告包括以下内容：
>
> - 警告类型：描述了问题的性质，例如漏洞类型。
> - 完整的跨入口污点流：详细说明了有害或污点数据如何从一个函数传播到另一个函数，包括涉及的函数调用序列。
> - 警告的顺序：指示了警告涉及的污点流的级别或阶层，例如"second-order vulnerability" 表示这是一个二阶漏洞，涉及到跨越两个不同的函数或函数调用的数据传播。

<img src="https://img1.imgtp.com/2023/10/16/AAsKdzaN.png" style="zoom:50%;" align="left"/>

## 静态分析设计

### 1.概况

参考另一篇论文的数据结构，以自上而下的方式对每个入口函数进行跨进程遍历，并对每个访问的LLVM IR进行别名污点分析，别名分析用于确定不同变量是否引用相同的内存位置，而污点分析用于追踪敏感数据的传播路径。然后更新与IR中涉及的变量相关的指向和污点信息。

> 这篇论文于2017年发表在第26届USENIX Security Symposium（USENIX Security 17）上。论文的主题是有关Linux内核驱动程序的安全性分析，特别是关于驱动程序的静态分析和安全性检测。研究的目标是提供一种"soundy analysis"，旨在更准确地检测Linux内核驱动程序中的潜在安全问题。这里提供了点更新和污点传播规则，深入了解时可以再看看这篇文章
>
> 在学习南京大学软件分析课程中指针分析介绍了有关别名分析的内容

### 2.定义

Def 0：作为模块的接口部分，在同一模块中没有其他函数或代码来调用这个入口函数，因为如果同一模块内的其他函数可以调用入口函数，可能会导致接口混乱和模块功能不明确。它通常是由外部实体直接调用的。

Def 1：污染源S，包括入口函数的用户提供参数(U)和所有全局可访问的变量或内存区域(G)。

> 不仅包括明确定义的全局变量，还包括可以从这些全局变量访问到的对象，即那些由全局变量引用的内存区域。这还包括了包含指向堆内存的指针字段的全局对象。这意味着污点源可以经过多层的指针间接引用，从而更复杂地跟踪有害数据的传播。
>
> 这个定义的目的是为了确定在进行污点分析时应该关注的数据源。它强调了用户提供的参数和全局内存中的数据，因为它们可能是程序中潜在的安全漏洞或有害数据的来源。在进行安全性分析时，污点源通常是需要仔细跟踪和审查的地方，以识别潜在的漏洞。

Def 2：具有偶数下标的指令表示调用方函数的入口指令，而奇数下标表示调用方内部的调用点指令（例如，𝑖2 是在𝑖1 处调用的函数的入口指令）。

<img src="https://img1.imgtp.com/2023/10/17/IWEEf3FY.png" style="zoom:80%;" align="left"/>

这个序列始终以当前执行函数的入口指令结束，因此其长度始终为奇数。这个定义使我们能够区分在同一调用点（例如，具有多个潜在目标的间接调用）上的多个被调用方。

<img src="https://img1.imgtp.com/2023/10/17/JaNsu0bq.png" alt="表现" style="zoom:80%;" align="left"/>

> - 这个定义描述了调用上下文的结构，它是一个由一系列指令组成的序列，这些指令代表程序执行的一系列步骤。
> - 调用上下文的目的是为了跟踪函数调用的过程。在序列中，偶数下标的指令表示调用方函数的入口指令，而奇数下标的指令表示在调用方内部的调用点指令。这使我们可以清楚地了解哪个函数在何处调用了其他函数，以及被调用的函数是什么。
> - 调用上下文的长度始终是奇数，因为它以当前执行函数的入口指令结束。这有助于确保上下文的完整性，从而准确表示函数调用的序列。
> - 这个定义的一个关键作用是区分在同一调用点发生的多个函数调用，特别是在涉及多个潜在目标的间接函数调用的情况下。通过追踪调用上下文，可以明确哪个函数是在给定的调用点上被调用的。
>
> 这个定义对于进行函数调用的分析和跟踪非常有用，特别是在安全性分析和程序分析中，它可以帮助确定哪个函数被调用，以及如何跟踪函数之间的调用关系。

Def 3：定义了一个指令地址，将指令i加上它的上下文，也就是Def 2 形成I，有助于在分析中明确指令的执行上下文，从而更好地理解程序的行为。

<img src="https://img1.imgtp.com/2023/10/17/1uwtn2NT.png" alt="def3" style="zoom:80%;" align="left"/>

Def 4：定义Def 3 所形成的的序列为污点流，第一个指令位置 𝐼0 用于初始化从一个污点源(Def 1)开始的污点传播，而剩余的指令位置负责将污点数据传递下去。

<img src="https://img1.imgtp.com/2023/10/17/YwK6Eye0.png" style="zoom:80%;" align="left"/>

Def 5：可以使用操作符 ◦ 判断污点流是否可以连接起来，当污点流的末尾等于另一个污点流开头时，将其连接，否则返回空集：

<img src="https://img1.imgtp.com/2023/10/17/dawerPi5.png" alt="def5" style="zoom: 67%;" align="left"/>

Def 6：定义两个函数reach()和order()

𝑟𝑒𝑎𝑐ℎ()函数确定一个函数位置是否可以到达另一个，𝑜𝑟𝑑𝑒𝑟()函数来确定整个污点流有没有达不到的，即中断点。

<img src="https://img1.imgtp.com/2023/10/17/khXl3x9l.png" alt="reach" style="zoom:67%;" align="left" />

𝐼𝐶𝐹𝐺(𝜀) 表示入口函数 𝜀 的程序间控制流图，I0 可以到达 I1 意味着至少有一次执行 𝜀 的过程可以在达到 I0 后继续执行，最终到达 I1。

<img src="https://img1.imgtp.com/2023/10/17/QWQ0Diid.png" alt="order" style="zoom: 67%;"  align="left"/>

缺点是由于 𝑟𝑒𝑎𝑐ℎ() 不具备传递性，污点流中可能存在比 𝑜𝑟𝑑𝑒𝑟() 计数的 "中断点" 更多的情况。

> 𝑟𝑒𝑎𝑐ℎ() 不具备传递性举例来说，𝑟𝑒𝑎𝑐ℎ(𝐼0, 𝐼1) ∧ 𝑟𝑒𝑎𝑐ℎ(𝐼1, 𝐼2) 未必会导致 𝑟𝑒𝑎𝑐ℎ(𝐼0, 𝐼2)，因为在 𝐼0 和 𝐼1 之间的路径可能对于在 𝐼1 和 𝐼2 之间的路径提出了冲突的约束，由于约束不能从I0到达I2，我们的 𝑜𝑟𝑑𝑒𝑟() 的定义可能低估了真正的污点流的顺序。换句话说，污点流中可能存在比 𝑜𝑟𝑑𝑒𝑟() 计数的 "中断点" 更多的情况，例如，通过 𝑟𝑒𝑎𝑐ℎ(𝐼0, 𝐼1) ∧ 𝑟𝑒𝑎𝑐ℎ(𝐼1, 𝐼2) 的结果，按 𝑜𝑟𝑑𝑒𝑟() 的计算， 𝐼0 和 𝐼2 之间没有 "中断点"，但实际上可能存在一个 "中断点"。然而，由于计算真正的顺序需要进行约束求解，这可能会变得昂贵。
>
> 而且，我们发现在实际应用中，这种低估情况很少发生。在实践中，污点流的 "中断点" 数量很少会超出 𝑜𝑟𝑑𝑒𝑟() 的计数，因此通常使用 𝑜𝑟𝑑𝑒𝑟() 进行估算是足够的。

Def 7：局部污点流集合

调用 𝜀 一次时可以产生的所有污点流的集合，自然地，我们有 ∀𝜏 ∈ 𝐿𝑇𝜀，𝑜𝑟𝑑𝑒𝑟(𝜏) == 1。

> 这个定义表明，局部污点流集合 𝐿𝑇𝜀 包含了在一个对入口函数 𝜀 的单次调用中可能产生的所有污点流。每个污点流都有一个顺序，即 𝑜𝑟𝑑𝑒𝑟(𝜏) 必定等于 1，因为这些污点流都是在单次函数调用内部产生的，没有跨越多个函数调用。这有助于分析函数内部的污点传播，而不涉及函数之间的交互。

### 3.基于**摘要**的高阶污点流构建

主要挑战是在面对入口函数可能的大量调用序列时，有效地构建高阶污点流。

SUTURE采用了基于摘要的方法，每个 𝜀 只需要分析一次以生成摘要，这样避免在不同序列中重复。然后通过连接局部污点流来高效构建高阶污点流，全局变量在连接局部污点流时起到中继点的作用。

> 全局变量：中继点
>
> 因为它们在不同函数之间提供了一个共享的数据存储和传递通道。这对于高阶污点流的构建非常有用，因为高阶污点流通常涉及多个函数的调用序列，其中污点数据需要跨越不同函数的边界传播。

比如一个局部污点流可以将用户输入的污点源传播到一个全局变量，然后另一个局部污点流可以将相同的全局变量（作为源）传播到一个关键的接收点。

过程有两个主要步骤：

1. 污点流摘要生成：首先，SUTURE对每个入口函数（𝜀）进行一次精确分析，生成有关其本地污点流的摘要。这些摘要包含了局部变量和全局变量之间的污点传播信息。这个步骤确保了局部污点流在函数内的正确记录。
2. 高阶污点流构建：一旦生成了摘要，SUTURE可以根据需要高效地构建高阶污点流。这是通过连接局部污点流来实现的，如在定义 5 中所描述。全局变量在此过程中充当关键的连接点，通过定义5判断是否可以连接，帮助将局部污点流串联起来。这允许污点源从一个局部流传播到一个全局变量，然后再从全局变量传播到另一个局部流，最终到达关键的接收点。

污点摘要的生成：

入口函数 𝜀 的污点摘要基本上是它的局部污点流集合 𝐿𝑇𝜀，SUTURE将局部污点流组织在 𝐿𝑇𝜀 中，通过与每个到达它的局部污点流（𝜏）关联的接收变量，而源变量可以通过每个 𝜏 关联的污点标签获得(污点标签稍后介绍)。这使得可以通过接收变量快速查询 𝜏，以及用于定义5构建高阶污点流的连接操作。

> 污点摘要包含了从污点源到入口函数中每个访问变量的污点流信息。这些局部污点流根据它们到达的接收变量进行组织，每个接收变量关联着一组局部污点流（𝜏）。同时，通过每个局部污点流关联的污点标签，可以获得源变量的信息。这种组织方式使得可以快速查询到达特定接收变量的污点流，以及用于构建高阶污点流的连接操作。

SUTURE与先前类似，但是每当指针涉及全局变量时，要解析它们可能会很具有挑战性，因为它们所指向的内存理论上可以在任何局部污点流中被更改。

<img src="https://img1.imgtp.com/2023/10/17/8ll7otN9.png" alt="举例" style="zoom: 67%;" align="left"/>

### 4.高阶污点流构建

连接两个局部污点流的重要因素：

1.全局内存匹配：匹配一个污点流中受污染的全局内存与另一个污点流中使用的全局内存，显式定义的全局内存，可以通过它们的标识符进行匹配。但对于通过全局指针访问的全局内存，情况更加复杂，需要更复杂的匹配策略。

> 案例
>
> 有四个入口函数：e0()、e1()、e2()和e3()。每个入口函数都与一个全局对象G.p相关联，其中G.p是一个指针字段，它可以指向动态分配的堆对象或静态定义的对象。
>
> e0()和e1()的任务是将G.p指向不同类型的对象，一个指向动态分配的堆对象，另一个指向静态定义的对象。同时，e2()和e3()的任务是直接访问G.p指向的对象。
>
> 问题是SUTURE在连接这些入口函数的局部污点流时必须正确地理解这些对象之间的关系。例如，e0()和e1()显然访问不同的对象实例，因此它们的局部污点流是不可连接的。但是e2()和e3()可以访问e0()和e1()中的对象，因此它们的局部污点流可以连接到彼此或者连接到e0()和e1()中的局部污点流。
>
> 要解决这个问题，SUTURE引入了一个机制，当对象在一个入口函数中被访问但没有在该函数中被定义时，它会创建一个占位符虚拟对象。这样的虚拟对象可以在连接局部污点流时起到关键作用，因为它们代表了可能的对象实例。通过访问路径匹配，SUTURE能够正确地连接局部污点流，即使在这种情况下，它不确定哪些对象实际被使用。

<img src="https://img1.imgtp.com/2023/10/17/FvbXwYQi.png" style="zoom:67%;"  align="left"/>

<img src="https://img1.imgtp.com/2023/10/17/LuW6aRpu.png" alt="image-20231017202536688" style="zoom: 67%;" align="left"/>

2.污点的覆盖与删除：并非所有的局部污点流都应该被保留以进行污点流连接，因为有可能调用的中间污染了全局内存，随后被清除了，SUTURE会过滤掉那些稍后会被覆盖的。

> 类似地，它也可能在函数中的不同点被不同的源污染。因此，SUTURE会过滤掉那些稍后会被覆盖的 𝜏。需要注意的是，这可能会阻止SUTURE发现一些污点风格的并发错误，其中一个 𝜀 中全局内存的中间污点可能对另一个可见。为了减少虚警污点流的数量，我们将更好地处理并发情况作为未来的工作。这意味着当前的版本可能不会捕获某些并发性污点问题，但为了降低误报的风险，我们将处理这类情况作为今后工作的一部分。

### 5.机会路径敏感分析

静态分析可能会沿着不可行的路径前进，因为它不了解冲突的路径约束，这会导致不准确性和低效性

> 不准确性 例如，无法进行污点传播；低效性 例如，分析不必要的分支

直接的解决方案是采用路径敏感性，然而，全面的路径敏感性分析可能会因复杂的约束求解和路径爆炸而变得过于昂贵。因此，我们的目标是在可能的情况下利用路径敏感性，同时避免高昂的成本。这就是机会性路径敏感性分析。其中有两个发现：

1. 内核中的路径约束中有相当一部分是简单的，但收集和解决这些约束可以帮助我们消除大量的不可行路径。
2. 我们可以将某种形式的路径敏感性分析机会地嵌入流敏感性分析的工作流程中。

于是在进入条件分支时，收集简单的路径约束，当分支合并时，移除约束。

> 仅以简单的形式收集，即变量 𝑣 与常量 𝐶（例如，文字数）之间的简单关系，例如 ==、>、<、≥、≤。每当我们的流敏感性分析进入条件分支时，我们会收集相应的约束，但只在它们具有简单形式的情况下。每当分支合并时，我们会移除这些约束。表面上，我们可能不允许进行路径敏感性分析，因为在合并点，在分支的合并点，不同的路径会汇聚成一个，导致路径的信息丢失，丢失了各个分支的约束，但我们注意到，在一个分支内部，可能会出现其他条件语句（在函数内或在不同函数之间），这使得我们有可能在机会性路径敏感性分析中通过在分支内部修剪不可行的路径，提高分析的准确性和效率。
>
> 1. **约束的修改：** 当进入一个条件分支内部，例如`if (x > 0)`，我们可能会有某些约束条件，比如`x > 0`。然而，在这个分支内部，可能会出现其他条件语句，例如`if (y < 10)`。如果这个新的条件是根据`x`的值来执行的（例如`if (x > 0 && y < 10)`），那么这就修改了我们对`x`的约束条件。这种情况下，原来的路径（`x > 0`为真）和新的路径（`x > 0`为真，同时`y < 10`为真）可能会导致不同的执行结果。
> 2. **路径剪枝：** 在一个条件分支内部，我们有机会根据新的约束条件来剪枝（即排除）不可行的路径。如果某些路径是由于新的约束条件而变得不可能，那么我们可以在分支内部通过机会性路径敏感性分析修剪掉这些不可行的路径，从而提高了分析的效率和准确性。
> 3. **调用关系：** 这种情况可能涉及到函数调用。在一个条件分支内部，一个函数可能调用另一个函数，而被调用函数可能会修改或进一步约束参数。这样，不同的路径可以通过不同的函数调用路径来改变约束条件。

机会路径敏感性是为了在一个分支内部出现其他条件语句时，这样就有可能通过机会性路径敏感性分析修剪掉不可行的路径。

<img src="https://img1.imgtp.com/2023/10/18/NIMkE9hG.png" alt="image-20231018104920750" style="zoom:67%;" align="left"/>

因为上面的函数和下面的函数都已经限制了cmd的值作为开关条件，因此这个调用上下文实际上只有一个有效的开关情况（第9行），机会性路径敏感性分析可以在第3行收集关于cmd的等式约束，并传播给被调用者。

> msm_lsm_ioctl()在第3行调用msm_lsm_ioctl_shared()，在其中有一个特定的开关情况，cmd受限于SNDRV_LSM_REG_SND_MODEL_V2。相同的cmd值传递给被调用者，并在第8行再次用作开关条件。由于在调用点（第3行）已经限制了其值，因此在这个调用上下文中实际上只有一个有效的开关情况（第9行）。我们的机会性路径敏感性分析可以在第3行收集关于cmd的等式约束，并传播给被调用者。这允许我们过滤掉17个中的16个不可行的开关情况，因为存在冲突的约束条件，从而同时提高了准确性和效率。

### 6.多源多汇对匹配问题

<img src="https://img1.imgtp.com/2023/10/18/XbF1w0k8.png" style="zoom:67%;" align="left"/>

> 图5用一个具体示例说明了这个问题。在开始分析函数`start_endpoints()` 时，参数`subs` 是一个指针，根据之前的静态分析结果，它指向`snd_usb_substream` 的两个实例。因此，在赋值语句的左侧（第2行）可能有两个内存位置（即`snd_usb_endpoint` 的`data_subs` 字段，实例0或1），而右侧的`subs` 指向`snd_usb_substream` 的实例0或1。在这种情况下，执行赋值的通常方式（就像许多流行的静态分析工具，如`Dr. Checker` 和`SVF` 所使用的方式）是"全对全"（例如，`snd_usb_endpoint` 的`data_subs` 字段将同时指向`snd_usb_substream` 的0和1实例）。然而，显然在实际程序执行中，`data_subs` 只能指向自己的父级`snd_usb_substream` 实例（例如，0指向0，1指向1）。我们称之为多源多汇对匹配问题，未能将这两个方面配对（例如，全对全更新）将创建许多多余的数据流事实。

> 为了解决这个问题，我们的关键观察是在上述情况中，赋值语句的两侧实际上共享相同的多样性源（例如，左侧的`ep0->data_subs` 在第2行具有两个可能的位置，因为`ep0` 可以指向两个结构实例，而`ep0` 之所以有这两个实例，是因为在第1行`subs` 也具有相同的原因，这也适用于右侧的情况），因此，只要运行时唯一源将多个可能性"合并" 为一个，赋值语句的两侧也会"合并"。基于这一观察，对于每个LLVM IR，它可以作为"多样性源"，例如，phi指令可以汇总来自不同路径的多个指向/污点记录到其接收变量，SUTURE分配每个独立的结果记录一个唯一的标签<𝐼𝑅，𝑖>（𝑖 是一个数值，用于区分多个多样性 𝐼𝑅 的结果记录），该标签也会传播到所有派生记录。例如，在图5中，指针`ep0` 是从`subs` 派生的，而`subs` 的`snd_usb_substream` 0和1的两个指向记录分别被传递给`ep0` 的`snd_usb_endpoint` 0和1的两个记录。通过匹配这些标签，当进行多对多的赋值操作时（例如，第2行），我们可以精确地配对源和汇，如果它们共享相同的多样性源，这将使图5中的2 * 2更新变成两个1 * 1 的更新。

## 漏洞发现和警告分组

生成污点摘要后，SUTURE可以继续发现高阶污点漏洞并输出警告报告。

步骤为：(1) 识别可能触发漏洞的指令（例如，算术指令可能导致整数溢出），这是由各种漏洞检测器完成的。对于每个已识别的指令，SUTURE通过判断是否有任何涉及的变量被用户污染（可能通过高阶流传播）来确认漏洞的存在；(2) 对已确认的漏洞触发和分组警告。

1.漏洞检测器

本文主要内容不在这里

## 静态分析

http://tai-e.pascal-lab.net/intro/overview.html

学习自南京大学软件分析课

https://ranger-nju.gitbook.io/static-program-analysis-book/笔记链接

1.不存在可以静态分析确切的分析出是否有空指针(non-trival properties)

2.静态分析：sound complete

sound：有假的 complete：是真的

<img src="https://img1.imgtp.com/2023/10/11/iIRyY9lV.png" alt="sound&complete" style="zoom:50%;" align="left" />

妥协sound：漏报；妥协complete：误报

<img src="https://img1.imgtp.com/2023/10/11/VY4Cu2xo.png" alt="区别" style="zoom:50%;" align="left" />

可以不精确但一定要sound

3.编译器和静态分析器关系

source code->词法分析判断是否合法(正则)->语法分析(上下文无关文法)->语义分析(类型检查)->优化->生成

4.AST&IR(三地址码)

IR更接近机器语言，不依赖于不同语言，很多语言都可以翻译成汇编，正统分析器表示形式

可以看出来循环控制流信息，便于静态分析

<img src="https://img1.imgtp.com/2023/10/12/UZSHa6Jd.png" alt="image-20231012135046686" style="zoom:50%;" align="left" />

右侧最多一个操作符；三地址指的是三种：(name;常量;编译器产生变量)

5.SSA

<img src="https://img1.imgtp.com/2023/10/12/IKjImrIL.png" alt="image-20231012162359199" style="zoom:50%;"  align="left"/>

优：对于部分流量不敏感的分析可以获得流量敏感的精度(变量的名字带了点数据流的信息)

缺：引入太多变量，效率问题

6.Control Flow Analysis 控制流图

Basic Blocks(BB)入口是唯一的出口也是唯一的，只能是第一条和最后一条

根据goto语句进行划分 如果某个指令是某个jump的target 则只能作为BB的入口，jump只能是出口。

规则：1.第一个指令是入口；2.jump的目标指令是入口；3.jump后面一条指令是入口 

其余依次连接

添边：1.有条件或无条件的goto,现语句与要goto的语句之间添边；2.出了无条件跳转，两条相邻语句之间添边

7.数据流分析应用

may analysis：可能正确；must analysis：一定正确

Reaching Definitions Analysis

在p处定义的v，在p到q中间v不能重新定义

8.指针分析

指针分析(程序中的指针能够指向哪个对象)与别名分析(任意两个指针是否指向同一个对象)

指针分析的要素：

1 堆抽象：如何对内存进行建模，把动态随程序不停产生的对象进行抽象，

使用allocation-site对其进行抽象，将循环生成的3个抽象成1个

<img src="C:\Users\李佳艺\AppData\Roaming\Typora\typora-user-images\image-20231019161129184.png" alt="image-20231019161129184" style="zoom:67%;" />

2 上下文敏感：

## end











