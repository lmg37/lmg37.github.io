---
layout: post
title: cache_lab
categories: csapp
description: cache
keywords: lab
---

# cache_lab

## part_A cache模拟器

定义一个cache[S] [E] 大小的二维数组

运行时读入要访问的地址在cache中寻找是否存在

地址(m位)：标记t位;组索引s位;块偏移b位  ->对应程序中的op_tag;op_s;op_b<img src="https://img1.imgtp.com/2023/10/10/3LOLtdax.png" alt="2" style="zoom: 50%;" />

高速缓存数组：

<img src="https://img1.imgtp.com/2023/10/10/SxTRp3FP.png" alt="1" style="zoom: 67%;"  />

如下：

![image-20231010201513058.png](https://img1.imgtp.com/2023/10/10/4J9TLh0J.png)



下面介绍代码组成

首先构建结构体 目的是作为二维数组方便查找是否有效和对时间戳进行更新

采用LRU(最近最少使用算法)进行调度

```c
typedef struct cache_line
{
	int valid;
	int tag;
	int time_tamp;
}Cache_line;
```

再构建cache整体结构体记录信息

```c
typedef struct cache_
{
	int S;//组 
	int E;//行 
	int B;//字节 
	Cache_line **line;//二维数组 S行E列 
}Cache;
```

下面是关于全局变量的设置

```c
int hit_count = 0,miss_count = 0,eviction_count = 0; //记录冲突命中、不命中、缓存不命中
int verbose = 0;//是否打印详细信息
char t[1000];
Cache *cache = NULL; 
```

下面是初始化cache的过程，其中S E B都已可以根据已知得出 将valid tag time_tamp进行初始化

```c
//cache初始设置
void Init_Cache(int s,int E,int b){
	int S = 1 << s; //2的s次幂 
	int B = 1 << b; //2的b次幂
	cache = (Cache *)malloc(sizeof(Cache));
	cache->S = S;//初始化cache的各个参数 
	cache->E = E;
	cache->B = B;
	cache->line = (Cache_line **)malloc(sizeof(Cache_line *) * S); //分配行数 
	for (int i = 0;i < S; i++){
		cache->line[i] = (Cache_line *)malloc(sizeof(Cache_line) * E); //分配列数 
		for(int j = 0; j < E; j++){ 
			cache->line[i][j].valid = 0;
			cache->line[i][j].tag = -1;
			cache->line[i][j].time_tamp = 0;
		}
	}
}
```

紧接着写出释放cache的函数

```c
void free_Cache(){
	int S = cache->S;
	for(int i = 0; i < S; i++){
		free(cache->line[i]);
	}
	free(cache->line);
	free(cache);
} 
```

下面介绍查找和LRU替换

查找索引是否命中

```c
//遍历所有行，如果某行有效且标记位相同则返回索引 不然返回-1
int get_index(int op_s, int op_tag){
    for (int i = 0; i < cache->E; i++)
    {
        if (cache->line[op_s][i].valid && cache->line[op_s][i].tag == op_tag)
            return i;
    }
    return -1;
}
//于是进行判满
//这里的工作是判断是不是因为满了需要替换返回的-1  还是，因为其中有空行 
int is_full(int op_s){
    for (int i = 0; i < cache->E; i++)
    {
        if (cache->line[op_s][i].valid == 0)
            return i;
    }
    return -1;
}
```

更新是否命中的信息

```c
void update_info(int op_tag,int op_s){
	int index = get_index();
	if(index==-1){//没命中 
		miss_count++;
		if(verbos)//是否打印详细信息
			printf("miss ");
		int i = is_full(op_s);
		if(i==-1){//全满了 
			eviction_count++;
            if(verbose) 
				printf("eviction");
            i = find_LRU(op_s);
		} 
		update(i,op_s,op_tag);
	}else{
		hit_count++;
        if(verbose)
            printf("hit");
        update(index,op_s,op_tag);
	}
}
```

命中后LRU更新时间戳

```c
//LRU更新代码
void update(int op_s,int j;int op_tag){
	cache->line[op_s][j].valid=1;
	cache->line[op_s][j].tag=op_tag;
	for(int k=0; k < cache->E; k++){
		if(cache->line[op_s][k].valid==1){
			cache->line[op_s][k].tamp++;
		}
	}
	cache->line[op_s][j].tamp = 0;//最后再把时间置零 因为最近被调用过
    //最后做的原因是刚才无差别将所有有效位为1的时间戳均增加了
}
```

更新完被调用的也要更新本组内其他的

```c
//找到要被替换的cache_line 选择排序 
int find_LRU(int op_s){
    int max_index = 0;
    int max_stamp = 0;
    for(int i = 0; i < cache->E; i++){
        if(cache->line[op_s][i].time_tamp > max_stamp){
            max_stamp = cache->line[op_s][i].time_tamp;
            max_index = i;
        }
    }
    return max_index;
}
```

从文件中得到地址和命令

```c
void get_trace(int s, int E, int b)
{
    FILE *pFile;
    pFile = fopen(t, "r");
    if (pFile == NULL)
    {
        exit(-1);
    }
    char identifier;
    unsigned address;
    int size;
    // Reading lines like " M 20,1" or "L 19,3"
    while (fscanf(pFile, " %c %x,%d", &identifier, &address, &size) > 0) 
    {
        //想办法先得到标记位和组序号
        int op_tag = address >> (s + b);
        int op_s = (address >> b) & ((unsigned)(-1) >> (8 * sizeof(unsigned) - s));
        先左移再右移（add<<(64-s-b))>>64-s
        switch (identifier)
        {
        case 'M': //一次存储一次加载 
            update_info(op_tag, op_s);
            update_info(op_tag, op_s);
            break;
        case 'L':
            update_info(op_tag, op_s);
            break;
        case 'S':
            update_info(op_tag, op_s);
            break;
        }
    }
    fclose(pFile);
}
```

输入`./csim -v -s 8 -E 2 -b 4 -t traces/yi.trace`进行调试

主函数如下所示 使用getopt分出指示

```c
int main(int argc, char *argv[])
{
    char opt;
    int s, E, b;
    /*
     * s:S=2^s是组的个数
     * E:每组中有多少行
     * b:B=2^b每个缓冲块的字节数
     */
    while (-1 != (opt = getopt(argc, argv, "hvs:E:b:t:")))
    {
        switch (opt)
        {
        case 'h':
            print_help();
            exit(0);
        case 'v':
            verbose = 1;
            break;
        case 's':
            s = atoi(optarg);
            break;
        case 'E':
            E = atoi(optarg);
            break;
        case 'b':
            b = atoi(optarg);
            break;
        case 't':
            strcpy(t, optarg);
            break;
        default:
            print_help();
            exit(-1);
        }
    }
    Init_Cache(s, E, b); //初始化一个cache
    get_trace(s, E, b);
    free_Cache();
    // printSummary(hit_count, miss_count, eviction_count)
    printSummary(hit_count, miss_count, eviction_count);
    return 0;
}
```

## part_B 优化

补充vim使用

shift+V  进入可视化界面；按j进行下移和跳转；y复制p粘贴

具体内容见师兄博客

https://ex7l0it.github.io/2023/07/16/vim/

### 32*32

<img src="https://img1.imgtp.com/2023/10/20/Ntjs6T2B.png" alt="image-20231019133053128" style="zoom:67%;" />

cache B=32 S=32 E=1 => int 4字节，可以放8个 int 32行

矩阵大小为32字节-32字节 cache大小为8字节-8字节

首先可以想到对矩阵进行分块，将32 * 32 =>8 * 32 将行列的miss损失降到最小

<img src="https://img1.imgtp.com/2023/10/12/RF43aC2m.png" alt="对应" style="zoom: 50%;"/>

第一小行和第一小列换时

<img src="https://img1.imgtp.com/2023/10/12/V1N2dmbK.png" alt="分块" style="zoom:50%;" />

第二小行和第二小列换时

```c
if (M == 32)
	{
		int i, j, m, n;
		for (i = 0; i < N; i += 8)//分块 8*8
			for (j = 0; j < M; j += 8)
				for (m = i; m < i + 8; ++m)//行列互换
					for (n = j; n < j + 8; ++n)
					{
						B[n][m] = A[m][n];
						//printf("B[%d][%d] = A[%d][%d]\n",n,m,m,n);
					}
	}
```

超过了300miss =>对角线访问问题

由于A和B的第一行都映射到缓存中同一块中，于是会造成图一的读对角线时 A1 B1 A1来回读的现象

于是决定读出A的一整行存到变量中，可以减少miss

具体代码如下：

```c
for (i = 0; i < N; i+=8) {
            for (j = 0; j < M; j+=8) {
                if(i == j){
                    for(k = i ;k < i + 8 && k<N;k++){ 
                        a0 = A[k][j];   
                        a1 = A[k][j+1];
                        a2 = A[k][j+2];
                        a3 = A[k][j+3];
                        a4 = A[k][j+4]; 
                        a5 = A[k][j+5];
                        a6 = A[k][j+6];
                        a7 = A[k][j+7];
                        B[j][k]   = a0;
                        B[j+1][k] = a1;
                        B[j+2][k] = a2;
                        B[j+3][k] = a3;
                        B[j+4][k] = a4;
                        B[j+5][k] = a5;
                        B[j+6][k] = a6;
                        B[j+7][k] = a7;
                    }
                }
                else{
                    for(k = i ;k < i + 8 && k<N;k++){
                        for(l = j ; l < j + 8 && l < M;l++)
                            B[l][k] = A[k][l];
                    }
                }
            }
        }
```

补充：

安装 `valgrind` 工具：

```bash
sudo apt-get install valgrind   # 对于基于 Debian 的系统
```

实验结果：

<img src="https://img1.imgtp.com/2023/10/20/zlxYuYu5.png" alt="32" style="zoom:80%;" />

### 64*64

对于矩阵的存储：

横：64/8=8组

竖：32/8=4行

如果像上面按照行划分4*4的块，每次Cache中放入8个int，我们却只用4个，浪费严重

题目说A数组不能变换，但是说B数组可以任意操作。考虑先把数字移动到B中，然后在B中自己做变化

1.先考虑把A的上半部分存入到B，但是为了考虑Cache不冲突，所以把右上角的4×4的区域也存在B的右上角。对于在对角线上的块，A的miss率是1/8，B的左上角部分miss率是1/2。对于不在对角线上的块，A的miss率还是1/8，B左上角部分的miss率为1/4.

2.接下来这步是减少miss率的关键，把A左下角的一列4个数据读出，B右上角的一行4个数据读出，都用int变量暂存，然后把前四个填入B右上角行中，后四个填入B的左下角行中。

因为从B右上角读取的时候，把块放入了Cache，然后从A往B中填的时候，就不会出现miss操作。

来计算一下miss率，对于在对角线上的块，从A左下角读取miss率为1，B的右上角的操作miss率为1/4，B的左下角miss率为1/4。对于不在对角线的快，A的miss率为1/4，B右上角miss率为0，左下角miss率为1/4。

3.最后一步就是把A的右下角填入B的右下角，对于在对角线上的块，A的miss率为1/4，B的miss率为1/2.不在对角线上的块，A，B的miss率都为0.

<img src="https://img1.imgtp.com/2023/10/20/z5ksV3tG.png" alt="image-20231019190629232" style="zoom:67%;"/>



<img src="https://img1.imgtp.com/2023/10/20/Ds3Y59bg.png" alt="64" style="zoom:67%;" />

### 61*67

由于限制条件比较宽，故逐一尝试

<img src="https://img1.imgtp.com/2023/10/20/PbsTUyf4.png" alt="image-20231019142111635" style="zoom:80%;" />

## 拓展优化矩阵乘法

